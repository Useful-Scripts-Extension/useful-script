/**
 * METADATA EXTRACTOR
 *
 * Extracts lightweight metadata from all scripts for fast popup loading
 * Run: node scripts/build/extractMetadata.js
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Mock chrome API for Node.js environment
global.chrome = {
  runtime: {
    getManifest: () => ({ version: '1.8' }),
    getURL: (path) => path,
  },
  storage: {
    local: {
      get: () => Promise.resolve({}),
      set: () => Promise.resolve(),
    },
  },
  scripting: {
    ExecutionWorld: {
      ISOLATED: 'ISOLATED',
      MAIN: 'MAIN',
    },
  },
};

// Mock window for scripts that might reference it
global.window = global.window || {};
global.document = global.document || {};

// Import shared detection logic
const { detectCanAutoRun, detectContexts, hasChildFunction } = await import("../helpers/scriptDetection.js");

// Now import all scripts
const allScriptsModule = await import("../@index.js");
const allScripts = allScriptsModule;

// Metadata fields to extract (no functions)
const METADATA_FIELDS = [
  'icon',
  'name',
  'description',
  'badges',
  'infoLink',
  'changeLogs',
  'whiteList',
  'blackList',
  'buttons',
  'priority'
];

function extractMetadata(script, scriptId) {
  const metadata = { id: scriptId };

  // Copy metadata fields
  METADATA_FIELDS.forEach(field => {
    if (script[field] !== undefined) {
      metadata[field] = script[field];
    }
  });

  // Use shared detection logic (same as popup/helpers/utils.js)
  metadata.contexts = detectContexts(script);
  metadata.canAutoRun = detectCanAutoRun(script);

  return metadata;
}

function generateMetadata() {
  console.log('üîç Extracting metadata from scripts...\n');

  const metadata = {};
  let count = 0;

  Object.entries(allScripts).forEach(([scriptId, script]) => {
    try {
      metadata[scriptId] = extractMetadata(script, scriptId);
      count++;

      if (count % 20 === 0) {
        console.log(`   Processed ${count} scripts...`);
      }
    } catch (error) {
      console.error(`‚ùå Error extracting ${scriptId}:`, error.message);
    }
  });

  console.log(`\n‚úÖ Successfully extracted metadata from ${count} scripts\n`);

  // Calculate size
  const fullSize = JSON.stringify(allScripts).length;
  const metaSize = JSON.stringify(metadata).length;
  const savings = ((1 - metaSize / fullSize) * 100).toFixed(1);

  console.log(`üìä Size comparison:`);
  console.log(`   Full scripts: ${(fullSize / 1024).toFixed(1)}KB`);
  console.log(`   Metadata only: ${(metaSize / 1024).toFixed(1)}KB`);
  console.log(`   Savings: ${savings}% smaller! üöÄ\n`);

  return metadata;
}

function writeMetadataFile(metadata) {
  const output = `/**
 * AUTO-GENERATED METADATA REGISTRY
 *
 * ‚ö†Ô∏è DO NOT EDIT MANUALLY!
 *
 * Generated by: node scripts/build/extractMetadata.js
 * Date: ${new Date().toISOString()}
 * Scripts: ${Object.keys(metadata).length}
 */

const metadata = ${JSON.stringify(metadata, null, 2)};

export default metadata;
`;

  const outputPath = path.join(__dirname, '..', '@metadata.js');
  fs.writeFileSync(outputPath, output, 'utf-8');

  console.log(`üìù Written to: scripts/@metadata.js\n`);
  console.log(`‚ú® Done! Popup will now load ${Object.keys(metadata).length} scripts instantly!\n`);
}

// Run extraction
try {
  const metadata = generateMetadata();
  writeMetadataFile(metadata);
  process.exit(0);
} catch (error) {
  console.error('‚ùå Fatal error:', error);
  process.exit(1);
}
